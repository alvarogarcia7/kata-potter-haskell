(:require [clojure.math.combinatorics :as combo])
(:require 'clojure.math.combinatorics :as combo)
(require 'clojure.math)
(require 'clojure.math.combinatorics)
(require 'clojure.math.combinatorics :as c)
(require 'clojure.math.combinatorics :as 'c)
(require 'clojure.math.combinatorics :as :c)
(require 'clojure.math.combinatorics as :c)
(source require)
(help require)
(doc require)
(clojure.math.combinatorics/combinations [1,2,3])
(clojure.math.combinatorics/combinations [1,2,3] 1)
(clojure.math.combinatorics/combinations [1,2,3] 2)
(clojure.math.combinatorics/combinations [1,2,3] 3)
(range 4)
(range 1 4)
(-> (range 1 4) clojure.math.combinatorics [1 2 3])
(->> (range 1 4) (clojure.math.combinatorics [1 2 3]))
(->> (range 1 4) (clojure.math.combinatorics/combinations [1 2 3]))
(->> (range 1 4) (map clojure.math.combinatorics/combinations [1 2 3]))
(->> (range 1 4) (map (clojure.math.combinatorics/combinations [1 2 3])))
(->> (range 1 4) (map (clojure.math.combinatorics/combinations [1 2 3] %)))
(->> (range 1 4) do-all (clojure.math.combinatorics/combinations [1 2 3]))
(->> (range 1 4) doall (clojure.math.combinatorics/combinations [1 2 3]))
(->> (range 1 4) doall)
(->> (range 1 4) (doall))
(->> (range 1 4) (doall) +)
(->> (range 1 4) (doall) (apply +))
(->> (range 1 4) (doall) (apply))
(->> (range 1 4) (doall) apply)
(map #(clojure.math.combinatorics/combinations [1 2 3]) (range 1 4))
(map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4))
(map id (map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4)))
(map identi (map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4)))
(map identity (map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4)))
(map vec (map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4)))
(reduce #(conj %1 %2) (map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4)))
(reduce #(cons %1 %2) (map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4)))
(reduce conj (map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4)))
(reduce cons (map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4)))
(reduce apply (map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4)))
(reduce (apply cons) (map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4)))
(reduce #(-> [%1 (apply cons %2)]) (map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4)))
(apply cons [1 2 3])
(apply list [1 2 3])
(apply list [[1 2 3]])
(apply apply [[1 2 3]])
(apply vec [[1 2 3]])
(apply vec '('(1 2 3)))
(apply vec '( '(1 2 3)))
(apply vec '( (1 2 3)))
(reduce #(-> [%1 (apply vec %2)]) (map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4)))
(reduce #(-> [%2 (apply vec %1)]) (map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4)))
(reduce #(apply vec %1 %2) (map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4)))
(reduce (partial apply vec) (map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4)))
(map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4))
(def combs (map #(clojure.math.combinatorics/combinations [1 2 3] %) (range 1 4))
)
combs
(first combs)
(apply vec (first combs))
(apply (comp map vec) (first combs))
(apply #(map vec %) (first combs))
(apply vec (first combs))
(map vec (first combs))
(apply (map vec (first combs)))
(apply identity (map vec (first combs)))
(apply vec (map vec (first combs)))
(flatten (map vec (first combs)))
(flatten (first combs))
(first combs)
combs
(flatten combs)
(mapcat identi combs)
(mapcat identity combs)
(def combs2 (mapcat identity combs))
combs2
(clojure.set/difference [1 2] [3])
(clojure.set/difference #(1 2) #(3))
(clojure.set/difference #{1 2} #{3})
(clojure.set/difference #{1 2} #{3 1})
(clojure.set/difference o combs2)
o
(def books [1,2,3])
books
(clojure.set/difference (set books) (set combs2))
combs2
(map #(clojure.set/difference (set books) (set %)))
(map #(clojure.set/difference (set books) (set %)) combs2)
(map vec (map #(clojure.set/difference (set books) (set %)) combs2) combs2)
(map vec [1 2] [2 3])
(mapv identity [1 2] [2 3])
(map identity [1 2] [2 3])
(doc map)
(map identity [1 2] [2 3])
(map conj [1 2] [2 3])
(map vector [1 2] [2 3])
(map vec [1 2] [2 3])
(doc vec)
(doc vector)
(map vector (map #(clojure.set/difference (set books) (set %)) combs2) combs2)
(map vector (list (map #(clojure.set/difference (set books) (set %)) combs2)) combs2)
(map vector (map #(list (clojure.set/difference (set books)) (set %)) combs2) combs2)
(map vector (map #(list (clojure.set/difference (set books) (set %))) combs2) combs2)
(map vector (map #(into list (clojure.set/difference (set books) (set %))) combs2) combs2)
(map vector (map #(clojure.set/difference (set books) (set %)) combs2) combs2)
(clojure.math.combinatorics/combinations [1,2,3] 1)
(clojure.math.combinatorics/combinations [1,2,3] 2)
(clojure.math.combinatorics/combinations [1,2,3] 3)
